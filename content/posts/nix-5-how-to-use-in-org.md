---
title: "Nix 详解（五）在大型组织中落地设计"
date: 2023-02-25T20:48:49+08:00
draft: true
toc: true
comments: true
tags:
  - untagged
---

> version: nix-2.14.1

## 场景推演

从代码角度来看，一个软件项目的需求开发的工作流大致为：代码设计、代码开发环境搭建、代码编写、代码测试、代码编译、代码部署。

根据前面几篇文章的说明，推荐将 Nix 应用在研发团队的工作流程如下场景：

**场景一：实现声明式的开发、测试、编译环境。**

Nix 相较其他包管理工具，最大的优势是声明式的和可重现的。因此，自然的可以使用 Nix 来声明一个项目的开发、测试、编译环境。 开发、测试、编译环境的依赖一般情况下是一致的，因此针对该场景：

* 需为项目添加一个 `shell.nix` 文件，声明项目的开发、测试、编译依赖。
* 开发、测试、编译相关的行为通过 shell 脚本实现，通过 shebang 注释应用上面的声明。

    ```bash
    #!/usr/bin/env nix-shell
    #! nix-shell -i bash --pure shell.nix
    ```

**场景二：组织内部自研面向内部成员的 CLI 工具发布平台。**

针对 Unix 平台的 CLI 工具，可以使用 Nix 来构建和发布 CLI。针对该场景：

* 类似于 nixpkgs，在组织内建设一个类似的代码仓库，管理所有需要发布 CLI 工具的 derivation 声明。
* 组织内 CI/CD 平台，提供构建能力，并将构建产物同步到二进制缓存服务。

**场景三：使用 Nix 构建后端服务的部署镜像（环境）？**

目前，Nix 函数式可重现的特性存在一个比较严重的问题，没有区分构建和运行依赖。

也就是说，一个软件包，即使其已经预构建好并存储在了二进制缓存服务中，但是在安装时，仍然会安装其编译依赖如编译器。

这就导致了，安装一个软件包的磁盘占用会异常的大。在云原生时代，一般部署环境对应一个镜像。

如果使用 Nix 来构建一个镜像，这就导致镜像大小比较大，且包含了没有必要的编译依赖。如果可以接受这一点，则即可使用 Nix 来构建部署镜像。

该问题，参见： [Issue](https://github.com/NixOS/nix/issues/8107)

## 架构图

## 相关服务和流程

### 二进制缓存聚合服务

缓存推送 CLI 工具

### 聚合 Channel 服务

### 标准 Nix 镜像

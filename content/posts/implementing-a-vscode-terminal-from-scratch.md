---
title: "从零开始实现一个 “VSCode Terminal”"
date: 2025-07-13T01:44:36+08:00
draft: true
toc: true
comments: true
tags:
  - untagged
---

> 本文源码: [rectcircle/implement-terminal-from-scratch](https://github.com/rectcircle/implement-terminal-from-scratch)

### 示例 2：实现一个简化版 Shell

在Linux中，作业（Job）、进程组（Process Group）和会话（Session）是用于管理和控制进程的关键概念。作业是指由用户在shell中启动的一组相关的进程，这些进程可以被当作一个整体来管理。进程组是将多个进程关联起来，以便进行批量操作，如发送信号。会话则是一系列进程组的集合，通常与一个登录会话相关联。
1. 作业(Job):
作业是用户在shell中启动的一组进程，通常是用户通过管道、重定向等方式将多个命令组合在一起形成的。
作业可以被暂停、恢复、终止。
在shell中，可以使用 jobs 命令查看当前会话中的作业，使用 fg 命令将后台作业调回前台，使用 bg 命令将停止的作业在后台继续运行。
例如，command1 | command2 & 启动了一个后台作业，其中 command1 和 command2 是相关的进程。
作业与进程组的区别在于，如果作业中的某个进程创建了子进程，子进程不一定属于同一个作业。
2. 进程组(Process Group):
进程组是进程的集合，通常与作业相关联，可以接收来自同一终端的信号。
每个进程组有一个唯一的进程组ID（PGID），通常等于组长进程的进程ID。
每个进程组可以有一个组长进程，当组长进程终止时，该进程组仍然存在，除非进程组中的最后一个进程也终止。
进程组主要用于进程管理和信号分发。
例如，setpgid(pid, pgid) 可以将进程 pid 加入到进程组 pgid 中。
3. 会话(Session):
会话是一系列进程组的集合，通常与一个登录会话相关联。
每个会话有一个会话首进程（session leader），即创建会话的进程。
会话可以有一个控制终端，用户通过该终端与系统交互。
会话中的进程组可以分为前台进程组和后台进程组。
当用户断开终端连接时，会话会收到SIGHUP 信号。
例如，setsid() 可以创建一个新的会话。
总结:
作业是用户层面的进程管理，通过shell命令进行控制。
进程组是更底层的概念，用于将多个进程组织在一起，便于信号传递和管理。
会话是最高层面的概念，用于将进程组组织在一起，通常与一个登录会话对应。
理解这些概念有助于更好地理解和控制Linux系统中的进程和作业。

### 示例 3：实现一个简化版 vim

TODO 终端窗口尺寸。

* `\x1b[?1049h\x1b[0m\x1b[2J\x1b[?1003h\x1b[?1015h\x1b[?1006h\x1b[?25l`

    * `\x1b[?1049h` ：启用备用屏幕缓冲区
    * `\x1b[0m` ：重置所有文本属性
    * `\x1b[2J` ：清除整个屏幕
    * `\x1b[?1003h` 、 `\x1b[?1015h` 、 `\x1b[?1006h` ：启用不同的鼠标报告模式
    * `\x1b[?25l` ：隐藏光标

1.光标控制：

* `\x1b[?25l` - 隐藏光标
* `\x1b[?25h` - 显示光标

2.屏幕清除：

* `\x1b[2J` - 清除整个屏幕
* `\x1b[H` - 将光标移动到左上角(1,1)位置

3.终端模式设置：

* `\x1b[?1049h` - 进入备用屏幕缓冲区
* `\x1b[?1049l` - 退出备用屏幕缓冲区

4.键盘输入模式：

* `\x1b[?1h` - 设置应用光标键模式
* `\x1b[?1l` - 重置光标键模式

---

Vim 在初始化终端界面时，会发送一系列 PTY escape codes（PTY 转义序列）来控制终端的行为，以便创建自己的文本用户界面（TUI）。这个过程通常包括清屏、隐藏光标、切换到备用屏幕缓冲区等操作。

以下是 `vim` 启动时发送给终端的一些典型的 PTY escape codes：

1. **进入备用屏幕缓冲区 (Enter Alternate Screen Buffer)**
    * Code: `\x1b[?1049h`
    * **作用**: 这个指令会保存当前的 shell 屏幕内容，并提供一个新的、空白的屏幕供 `vim` 使用。当你退出 `vim` 时，它会恢复之前的 shell 屏幕，看起来就像 `vim` 从未打开过一样。这是实现全屏应用（如 `vim`, `less`, `htop`）的关键。

2. **隐藏光标 (Hide Cursor)**
    * Code: `\x1b[?25l` (最后一个字符是小写的 'L')
    * **作用**: 在 `vim` 绘制其界面时，为了防止光标在屏幕上闪烁或乱跳，会先将光标隐藏。

3. **清空整个屏幕 (Clear Screen)**
    * Code: `\x1b[2J`
    * **作用**: 清除备用屏幕上的所有内容，为绘制 `vim` 的界面做准备。

4. **移动光标到左上角 (Move Cursor to Home Position)**
    * Code: `\x1b[H` 或 `\x1b[1;1H`
    * **作用**: 将光标定位在屏幕的左上角（第 1 行，第 1 列），这是绘制界面的起点。

5. **设置文本属性 (Set Text Attributes)**
    * Code: `\x1b[0m`
    * **作用**: 重置所有文本属性（如颜色、粗体、下划线等），确保 `vim` 在一个干净的样式环境中开始绘制。之后，`vim` 会根据你的配色方案（colorscheme）发送其他代码来设置前景和背景颜色。

在执行完这些初始设置后，`vim` 会开始发送大量的文本和夹杂在其中的其他转义序列来绘制界面，包括状态栏、命令行、文件内容区域（用 `~` 表示空行）等。

当所有内容绘制完毕，`vim` 会将光标移动到文件中的初始位置，并重新显示光标：

* **显示光标 (Show Cursor)**: `\x1b[?25h`

因此，`vim` 启动时发送给终端的原始字节流（简化后）可能看起来像这样：
`"\x1b[?1049h\x1b[?25l\x1b[2J\x1b[H\x1b[0m... (大量用于绘制UI的文本和代码) ...\x1b[?25h"`

当你退出 `vim` 时，它会发送相反的指令来恢复终端：
1. **清屏**: `\x1b[2J`
2. **显示光标**: `\x1b[?25h`
3. **退出备用屏幕缓冲区**: `\x1b[?1049l`

这个精确的控制序列使得 `vim` 能够在终端内提供一个独立的、功能丰富的编辑环境。

---

好的，您说得对。我之前的解释主要集中在屏幕和光标的初始化上。鼠标支持是 `vim` 利用的另一个层面的终端控制技术。

`vim` 支持鼠标并不是通过原生的图形界面（GUI）机制，而是通过指示终端（Terminal）本身将鼠标事件作为字符流来报告，就像报告键盘按键一样。这个过程同样是通过 PTY escape codes（PTY 转义序列）实现的。

工作原理如下：

1. **启用鼠标报告 (Enabling Mouse Reporting)**
    当您在 `vim` 中启用鼠标支持时（例如，在 `.vimrc` 中设置 `set mouse=a`），`vim` 会向终端发送一个特定的转义码。最常见的是用于“X10 兼容模式”或更现代的“SGR 模式”的转义码。

    * **启用普通鼠标报告**: `\x1b[?1000h`
        这会告诉终端报告鼠标的点击和释放事件。
    * **启用按钮移动鼠标报告**: `\x1b[?1002h`
        这会告诉终端在按住按钮并移动鼠标时（即拖动）也报告事件。
    * **启用 SGR 扩展鼠标模式**: `\x1b[?1006h`
        这是一种更新、更健壮的模式，它使用不同的格式来报告事件，避免了某些歧义，并支持超过 223 的坐标。大多数现代终端都支持此模式。

2. **终端将鼠标事件作为文本报告**
    一旦启用了鼠标报告，如果您在终端窗口中点击、滚动或拖动，终端模拟器不会执行其默认操作（如选择文本）。相反，它会将鼠标事件转换成一个字符序列，并将其发送到 `vim` 的标准输入，就好像您在键盘上输入了这些字符一样。

    例如，在启用 SGR 模式 (`1006`) 的情况下，在第 20 列、第 10 行进行一次左键单击，终端会向 `vim` 发送如下序列：
    `\x1b[<0;20;10M`

    * `\x1b[<`: SGR 鼠标报告的开始。
    * `0`: 按钮代码（0 代表左键按下，1 代表中键，2 代表右键；其他数字用于滚轮等）。
    * `20`: 列坐标。
    * `10`: 行坐标。
    * `M`: 表示按钮按下（小写的 `m` 表示按钮释放）。

3. **Vim 解析转义码**
    `vim` 会持续从其输入流中读取数据。当它看到这个特殊的序列时，它不会将其作为文本显示在屏幕上，而是会解析这个序列并理解其含义：“用户在第 10 行，第 20 列单击了左键。”

4. **Vim 执行相应操作**
    根据解析出的事件，`vim` 会执行相应的操作，例如：
    * 将光标移动到该位置。
    * 如果您拖动鼠标，则开始一个可视化选择。
    * 如果您中键单击，则粘贴文本。
    * 如果您使用滚轮，则向上或向下滚动视图。

5. **禁用鼠标报告**
    当您退出 `vim` 时，它会向终端发送相应的“禁用”代码，例如 `\x1b[?1000l`、`\x1b[?1002l` 或 `\x1b[?1006l`（注意最后的字符是 `l` 而不是 `h`）。这将使终端恢复其正常行为，即鼠标用于在终端缓冲区中选择文本，而不是向正在运行的应用程序发送事件。

总结来说，`vim` 通过告诉终端将鼠标操作转换为特殊的文本序列来“劫持”鼠标，然后 `vim` 拦截并解释这些序列，从而在其基于文本的界面中提供鼠标驱动的功能。

---

当 `vim` 退出时，它会发送一系列 PTY escape codes 来将终端恢复到其原始状态。这个过程基本上是启动时所做操作的逆向操作。

以下是 `vim` 退出时发送的一些关键 PTY escape codes：

1. **禁用鼠标报告 (Disable Mouse Reporting)**
    * Codes: `\x1b[?1000l`, `\x1b[?1002l`, `\x1b[?1006l` (注意最后的字符是小写的 'L')
    * **作用**: 如果在 `vim` 会话中启用了鼠标（例如 `set mouse=a`），`vim` 会发送这些指令来禁用它。这使得终端的鼠标功能恢复正常，例如，可以用鼠标选择和复制终端中的文本，而不是将点击事件发送给应用程序。

2. **显示光标 (Show Cursor)**
    * Code: `\x1b[?25h`
    * **作用**: 这个指令会使光标重新变得可见。`vim` 在启动时通常会用 `\x1b[?25l` 将其隐藏，以防止在绘制界面时出现闪烁。

3. **退出备用屏幕缓冲区 (Exit Alternate Screen Buffer)**
    * Code: `\x1b[?1049l`
    * **作用**: 这是最关键的一步。`vim` 在启动时使用 `\x1b[?1049h` 切换到了一个“备用屏幕”，以便拥有一个独立的全屏界面。退出时，发送这个 `l` 结尾的指令会**恢复之前的主屏幕缓冲区**。这意味着你之前在 shell 中的所有内容会重新出现，终端光标也会恢复到 `vim` 启动前的位置，就好像 `vim` 从未打开过一样。

4. **重置文本属性 (Reset Text Attributes / SGR)**
    * Code: `\x1b[0m`
    * **作用**: 清除所有特殊的文本格式（如颜色、粗体、下划线等），将终端的文本样式恢复到默认值。

因此，`vim` 退出时发送给终端的字节流（简化后）看起来像这样：
`"\x1b[?1006l\x1b[?25h\x1b[?1049l\x1b[0m"`

这个恢复过程确保了 `vim` 在关闭后不会留下任何“后遗症”，让用户可以无缝地回到他们的命令行工作中。

## VSCode 终端 和 Shell 集成分析

### 完整实例：在 WebShell 中记录命令执行情况的结构化数据

## VSCode 终端相关扩展 API

> 以示例讲解，写一个插件探测 VSCode 终端 Shell 集成情况。

### 完整实例：在 WebShell 提供可扩展的 API
